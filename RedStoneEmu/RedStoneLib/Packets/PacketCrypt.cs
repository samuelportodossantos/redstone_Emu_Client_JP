using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RedStoneLib.Packets
{
    /// <summary>
    /// パケットの暗号化・復号化を扱うクラス
    /// </summary>
    public static class PacketCrypt
    {
        /// <summary>
        /// エンコード定数1
        /// </summary>
        static uint LoginServerEncodeCode1 = 0x6F;

        /// <summary>
        /// エンコード定数2
        /// </summary>
        static uint LoginServerEncodeCode2 = 0x40;

        /// <summary>
        /// ログイン系の文字列復号化乱数種１
        /// </summary>
        static uint LoginServerPacketEncodeSeedValue1 = 0x64;

        /// <summary>
        /// ログイン系の文字列復号化乱数種２
        /// </summary>
        static uint LoginServerPacketEncodeSeedValue2 = 0x64;

        /// <summary>
        /// パケットを復号化
        /// </summary>
        /// <param name="data"></param>
        /// <param name="len"></param>
        /// <param name="packetType"></param>
        /// <returns></returns>
        public static byte[] DecryptPacket(byte[] data, uint len, uint packetType)
        {
            RedStoneRandom rand = new RedStoneRandom(packetType);

            uint randRange = packetType % LoginServerEncodeCode1 + LoginServerEncodeCode2;

            return data.Select(t => (byte)(t - (byte)(rand.Next(randRange) + 0x7C))).ToArray();
        }

        /// <summary>
        /// パケットを暗号化
        /// </summary>
        /// <param name="data"></param>
        /// <param name="len"></param>
        /// <param name="packetType"></param>
        /// <returns></returns>
        public static byte[] EncryptPacket(byte[] data, uint len, uint packetType)
        {
            RedStoneRandom rand = new RedStoneRandom(packetType);

            uint randRange = packetType % LoginServerEncodeCode1 + LoginServerEncodeCode2;

            return data.Select(t => (byte)(t + (byte)(rand.Next(randRange) + 0x7C))).ToArray();
        }

        /// <summary>
        /// 文字列を復号化
        /// </summary>
        /// <param name="securityCode"></param>
        /// <param name="str"></param>
        /// <returns></returns>
        public static string DecodeLoginString(ushort securityCode, byte[] str)
        {
            var rand = new RedStoneRandom(securityCode);

            uint range = securityCode % LoginServerPacketEncodeSeedValue1 + LoginServerPacketEncodeSeedValue2;

            uint sum = 0;
            List<byte> decoded = new List<byte>();
            foreach (byte b in str)
            {
                sum += b;
                if (range == 0)
                {
                    // if zero
                }
                decoded.Add((byte)(b - (byte)rand.Next(range)));
            }
            return Helper.SjisByteToString(decoded.ToArray());
        }

        /// <summary>
        /// 復号化キーを生成
        /// </summary>
        /// <param name="seed"></param>
        /// <returns></returns>
        public static uint GenerateScenarioDecodeKey(int seed)
        {
            if (seed == -1) return 0;
            return (uint)(2 - (seed != 1 ? 1 : 0));
        }

        /// <summary>
        /// Scenario暗号化されたバッファのデコード
        /// </summary>
        /// <param name="data"></param>
        /// <param name="decodeKey"></param>
        /// <returns></returns>
        public static byte[] DecodeScenarioBuffer(byte[] data, uint decodeKey)
        {
            byte[] result = new byte[data.Length];
            byte tableOffset = (byte)(((decodeKey * 9) << 3) - decodeKey);
            byte encCounter = 0;
            int shu = 0;
            for (int i = 0; i < data.Length; i++)
            {
                byte endata = (byte)(aucDataTable[encCounter + tableOffset] + xorKeys[encCounter + tableOffset]);
                result[i] = (byte)(data[i] ^ endata);
                encCounter++;
                if (shu == 0) Console.Write(aucDataTable[encCounter + tableOffset].ToString("x2") + ";");
                if (encCounter >= 0x47)
                {
                    encCounter = 0;
                    if (shu == 0)
                    {
                        shu = 1;
                        Console.WriteLine("");
                    }
                }
            }
            return result;
        }

        /// <summary>
        /// Scenario暗号の鍵1
        /// </summary>
        private static byte[] aucDataTable =
            {0xAF, 0x7E, 0xF5, 0xE7 ,0xDD ,0xF9 ,0xBE ,0xEE ,0xED ,0xBE ,0xCF ,0xBE ,0x9F ,0xBB ,0x7B ,0xE7
            ,0xE7, 0x5F, 0xF5, 0xEE ,0xF5 ,0xEE ,0xBE ,0xF6 ,0xED ,0xFA ,0x77 ,0x3F ,0xE7 ,0x9F ,0xEB ,0x3F
            ,0xF3, 0xF3, 0xDE, 0xF3 ,0x77 ,0xDD ,0xF3 ,0xE7 ,0x7E ,0xEE ,0xED ,0xDD ,0xE7 ,0xF5 ,0x3F ,0xEB
            ,0x3F, 0x3F, 0x7D, 0x77 ,0xFA ,0xD7 ,0xEB ,0xED ,0xEE ,0xE7 ,0x7E ,0xAF ,0x9F ,0xBB ,0xF3 ,0xFC
            ,0xDE, 0xDE, 0xBE, 0xDE ,0x7E ,0xF9 ,0x9F ,0xF5 ,0xBD ,0xFC ,0x7D ,0xF9 ,0xDE ,0xBD ,0xDB ,0xDE
            ,0x6F, 0xFC, 0xE7, 0xAF ,0xBD ,0x5F ,0x7D ,0x6F ,0x7B ,0x77 ,0xBD ,0xF6 ,0xDB ,0xAF ,0xF6 ,0xB7
            ,0x6F, 0xB7, 0xBB, 0xCF ,0x9F ,0x5F ,0xF5 ,0x7D ,0xFA ,0x7E ,0x7B ,0xE7 ,0xF5 ,0xDD ,0x5F ,0xCF
            ,0x77, 0xEB, 0xDE, 0xF5 ,0x5F ,0x6F ,0x77 ,0x9F ,0xAF ,0xEE ,0x7B ,0x6F ,0xCF ,0xDD ,0xDD ,0xBE
            ,0xFA, 0x9F, 0xCF, 0x7D ,0xCF ,0xBE ,0x7B ,0xFC ,0xF5 ,0xDB ,0xDE ,0xE7 ,0xEE ,0xF9 ,0xF9 ,0xDD
            ,0xF3, 0xDE, 0xF5, 0xCF ,0x6F ,0xCF ,0xDB ,0xBB ,0xFA ,0xFC ,0xF9 ,0xF6 ,0xE7 ,0xDB ,0xFC ,0xF3
            ,0xB7, 0xCF, 0x6F, 0xDD ,0xD7 ,0xF9 ,0xBB ,0x7D ,0xBD ,0xDD ,0x3F ,0x5F ,0xDE ,0xF6 ,0x7E ,0xE7
            ,0xFA, 0xBE, 0xCF, 0xE7 ,0xAF ,0xFA ,0xBE ,0xFA ,0xEB ,0xBE ,0xAF ,0xE7 ,0xBE ,0xDE ,0xF9 ,0x3F
            ,0xF3, 0x6F, 0xCF, 0x6F ,0xB7 ,0xB7 ,0xEE ,0xF6 ,0xCF ,0xF3 ,0x9F ,0xDB ,0x7B ,0xD7 ,0xEB ,0xED
            ,0x3F, 0xED, 0xF3, 0x77 ,0xAF ,0x00 ,0x00 ,0x00 ,0x40 ,0x00 ,0x00 ,0x00 ,0x48 ,0x00 ,0x00 ,0x00
            ,0xD4, 0x5A, 0xAE, 0x3F ,0x04 ,0x00 ,0x00 ,0x00 ,0x6F ,0x00 ,0x00 ,0x00 ,0x40 ,0x00 ,0x00 ,0x00
            ,0x49, 0x00, 0x00, 0x00 ,0x45 ,0x00 ,0x00 ,0x00 ,0xFD ,0xFE ,0x00 ,0x00 ,0x09 ,0x00 ,0x00 ,0x00
            ,0x08, 0x00, 0x00, 0x00 ,0x64 ,0x00 ,0x00 ,0x00 ,0x64 ,0x00 ,0x00 ,0x00 ,0x7B ,0x7D ,0xB7 ,0xBD
            ,0xAF, 0xBB, 0x3F, 0x7D ,0xDB ,0xAF ,0xEE ,0xB7 ,0x7E ,0x7E ,0xF6 ,0x77 ,0x77 ,0xBB ,0xE7 ,0x77
            ,0x9F, 0x7B, 0xF6, 0x7D ,0xF5 ,0xF5 ,0x6F ,0x5F ,0xED ,0x7E ,0xDE ,0xF3 ,0xF5 ,0xF5 ,0x9F ,0xDE
            ,0xF3, 0xFC, 0xEB, 0xF9 ,0x5F ,0xAF ,0xF3 ,0xD7 ,0xFA ,0xDD ,0x5F ,0xBB ,0xEB ,0xE7 ,0xD7 ,0xD7
            ,0xF3, 0xD7, 0x7B, 0x7D ,0xF5 ,0xEB ,0xBB ,0xF5 ,0x7E ,0xDD ,0xFA ,0xCF ,0xED ,0xFA ,0xFA ,0xF6
            ,0xEE, 0xF6, 0x6F, 0x00 ,0x7B ,0x7D ,0xB7 ,0xBD ,0xAF ,0xBB ,0x3F ,0x7D ,0xDB ,0xAF ,0xEE ,0xB7
            ,0x7E, 0x7E, 0xF6, 0x77 ,0x77 ,0xBB ,0xE7 ,0x77 ,0x9F ,0x7B ,0xF6 ,0x7D ,0xF5 ,0xF5 ,0x6F ,0x5F
            ,0xED, 0x7E, 0xDE, 0xF3 ,0xF5 ,0xF5 ,0x9F ,0xDE ,0xF3 ,0xFC ,0xEB ,0xF9 ,0x5F ,0xAF ,0xF3 ,0xD7
            ,0xFA, 0xDD, 0x5F, 0xBB ,0xEB ,0xE7 ,0xD7 ,0xD7 ,0xF3 ,0xD7 ,0x7B ,0x7D ,0xF5 ,0xEB ,0xBB ,0xF5
            ,0x7E, 0xDD, 0xFA, 0xCF ,0xED ,0xFA ,0xFA ,0xF6 ,0xEE ,0xF6 ,0x6F ,0x00 ,0xD0 ,0xC0 ,0x7C ,0x00
            ,0xC0, 0xC0, 0x7C, 0x00 ,0xB4 ,0xC0 ,0x7C ,0x00 ,0xA8 ,0xC0 ,0x7C ,0x00 ,0xA0 ,0xC0 ,0x7C ,0x00
            ,0x98, 0xC0, 0x7C, 0x00 , 0xA0, 0x31, 0x7D, 0x00};

        /// <summary>
        /// Scenario暗号の鍵２（xorKey）
        /// </summary>
        private static byte[] xorKeys =
            {0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ,0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ,0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ,0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ,0x00, 0x00, 0x00, 0x00 , 0x00, 0x00, 0x00, 0x3F, 0x5F, 0xB7, 0x7D, 0xE7, 0xCF, 0xFA, 0x5F, 0xDB
            ,0xCF, 0xAF, 0xDD, 0x7E , 0xEB, 0xEE, 0xED, 0x7E, 0xDE, 0x77, 0xCF, 0x7E, 0xD7, 0xEE, 0xB7, 0xBD
            ,0x6F, 0x9F, 0x7D, 0xBE , 0xE7, 0xED, 0x6F, 0xDD, 0xED, 0xDB, 0xF3, 0xDB, 0xAF, 0x3F, 0xDB, 0xEE
            ,0xD7, 0x7D, 0xDD, 0x6F , 0x9F, 0x6F, 0xAF, 0x7E, 0x5F, 0x3F, 0x7E, 0xFA, 0x77, 0xBE, 0xFA, 0x9F
            ,0xE7, 0xE7, 0xBB, 0xDD , 0xDD, 0xED, 0xE7, 0xEE, 0x9F, 0x7B, 0xEE, 0xAF, 0x5F, 0xAF, 0xBD, 0xBB
            ,0x7E, 0x6F, 0x7D, 0xCF , 0xF3, 0x9F, 0x9F, 0xB7, 0xDD, 0xD7, 0xED, 0x7D, 0xBB, 0xDB, 0xBB, 0xDB
            ,0x9F, 0xED, 0xBB, 0xBB , 0xEB, 0xDE, 0xAF, 0xDB, 0x5F, 0xFA, 0x6F, 0xB7, 0xCF, 0xBE, 0xDE, 0xAF
            ,0xB7, 0xDD, 0xB7, 0xAF , 0x6F, 0xDE, 0xEB, 0xE7, 0x6F, 0x3F, 0xF3, 0xFA, 0xF3, 0xBB, 0xFC, 0x7E
            ,0xDD, 0x7E, 0xE7, 0x7E , 0xB7, 0xBE, 0xEE, 0xFA, 0xF9, 0xB7, 0x5F, 0x7B, 0xED, 0x3F, 0x7B, 0x6F
            ,0xB7, 0xD7, 0x6F, 0xFC , 0x9F};
    }

    /// <summary>
    /// RedStone専用の乱数発生器
    /// </summary>
    class RedStoneRandom
    {
        /// <summary>
        /// 乱数のシード
        /// </summary>
        private uint Seed = 0;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        /// <param name="seed"></param>
        public RedStoneRandom(uint seed)
        {
            this.Seed = seed;
        }

        /// <summary>
        /// 指定した最大値より小さい0以上のランダムな値を返す
        /// </summary>
        /// <param name="maxValue"></param>
        /// <returns></returns>
        public uint Next(uint maxValue)
        {
            //シードを更新
            Seed = Seed * 0x343FD + 0x269EC3;

            //シードによる乱数の結果
            uint resultBySeed = (Seed >> 0x10) & 0x7FFF;

            //範囲で割って返す
            return resultBySeed % maxValue;
        }
    }
}
